"""
Copyright 2022 by Herbert Potechius,
Ernst-Abbe-Hochschule Jena - University of Applied Sciences - Department of Electrical Engineering and Information
Technology - Immersive Media and AR/VR Research Group.
All rights reserved.
This file is released under the "MIT License Agreement".
Please see the LICENSE file that should have been included as part of this package.
"""


import time
import numpy as np
import os
import math
#os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3' # 0: DEBUG, 1: INFO, 2: WARNING, 3: ERROR

from ColorTransferLib.MeshProcessing.PLYLoader import PLYLoader
from ColorTransferLib.MeshProcessing.Mesh import Mesh
from ColorTransferLib.MeshProcessing.Mesh2 import Mesh2
from ColorTransferLib.ImageProcessing.Image import Image
from ColorTransferLib.ColorTransfer import ColorTransfer, ColorTransferEvaluation

from ColorTransferLib.Utils.Math import get_random_3x3rotation_matrix
import cv2
import tensorflow_probability as tfp
import tensorflow as tf
import matplotlib.pyplot as plt
from torch import nn
from torch.functional import F
from copy import copy
import gdown
import zipfile36 as zipfile
import random
import requests

# ------------------------------------------------------------------------------------------------------------------
#
# ------------------------------------------------------------------------------------------------------------------
def img2img_test(src_path, ref_path, ct_approach):
    src = Image(file_path=src_path)
    ref = Image(file_path=ref_path)
    ct = ColorTransfer(src, ref, ct_approach)
    output = ct.apply()
    return output

# ------------------------------------------------------------------------------------------------------------------
# Reads the file generated by "createEvaluationFile(...)" and creates an output image which concatenates source,
# reference and output horizontally.
#
# Parameters:
# ALG [String]: Identifier of the algorithm which has to be evaluated; Example: GLO, FCM, etc.
# dataset_path [String]: Path to the ACM-MM-Evaluation-Dataset
# outpath [String]: Path where all outputs will be saved
# ------------------------------------------------------------------------------------------------------------------
def evaluationCreateOutputs(ALG, dataset_path, outpath):
    times_arr = []
    total_tests = 0

    size = "2048"
    file1 = open(dataset_path)
    for total_tests, line in enumerate(file1.readlines()):
        print(total_tests)

        # read source and reference
        s_p, r_p = line.strip().split(" ")
        src_img = dataset_path + s_p
        ref_img = dataset_path + r_p
        src = Image(file_path=src_img)
        ref = Image(file_path=ref_img)

        # Skip files which were already created
        file_name = outpath + ALG+"/"+s_p.split("/")[1].split(".")[0] +"__to__"+r_p.split("/")[1].split(".")[0]+".png"
        if os.path.isfile(file_name):
            continue

        # Apply Color Transfer
        ct = ColorTransfer(src, ref, ALG)
        output = ct.apply()

        if output["status_code"] == -1:
            print("\033[91mTypeError\033[0m: " + output["response"])
            exit()

        file_name = outpath + ALG+"/"+s_p.split("/")[1].split(".")[0] +"__to__"+r_p.split("/")[1].split(".")[0]+".png"
        ou = np.concatenate((src.get_raw(), ref.get_raw(), output["object"].get_raw()), axis=1) 
        cv2.imwrite(file_name, cv2.cvtColor(ou, cv2.COLOR_BGR2RGB)*255)

        # elif ct_input == "pc-pc" or ct_input == "pc-img":
        #     out_loader = PLYLoader(mesh=output["object"])
        #     out_loader.write("/home/potechius/Downloads/"+ct_approach+".ply")

    file1.close()

# ------------------------------------------------------------------------------------------------------------------
# Reads the file generated by "createEvaluationFile(...)" and estimates the process time of a given algorithm
#
# Parameters:
# ALG [String]: Identifier of the algorithm which has to be evaluated; Example: GLO, FCM, etc.
# dataset_path [String]: Path to the ACM-MM-Evaluation-Dataset
# outfile [String]: Path of the .txt file which will contain all process times per example
# ------------------------------------------------------------------------------------------------------------------
def evaluationProcessTime(ALG, dataset_path, outfile):
    times_arr = []
    total_tests = 0

    file1 = open(outfile)
    for line in file1.readlines():
        total_tests += 1
        print(total_tests)
        s_p, r_p = line.strip().split(" ")
        src_img = dataset_path + s_p
        ref_img = dataset_path + r_p

        src = Image(file_path=src_img)
        ref = Image(file_path=ref_img)
   
        ct = ColorTransfer(src, ref, ALG)
        output = ct.apply()

        times_arr.append(output["process_time"])
        print("TOTAL: " + str(output["process_time"]))

    # calculate mean
    mean = sum(times_arr) / len(times_arr)

    # calculate std
    std = 0
    for t in times_arr:
        std += math.pow(t-mean, 2)
    std /= len(times_arr)
    std = math.sqrt(std)


    print("Averaged: " + str(round(mean,3)) + " +- " + str(round(std,3)))
    file1.close()

# ------------------------------------------------------------------------------------------------------------------
# Downloads necessary objects, e.g., network models, to the correct location 
# ------------------------------------------------------------------------------------------------------------------
def downloadMaterial():
    if not os.path.exists("Models") and not os.path.exists("data"):
        print("Download DATA.zip ...")
        url = "https://drive.google.com/file/d/1ShJpPFJ9vCu5Vb7FJk7aSnn7ywFiT0GJ/view?usp=share_link"
        output_path = 'DATA.zip'
        gdown.download(url, output_path, quiet=False, fuzzy=True)
        # Extract DATA.zip
        print("Extract DATA.zip ...")
        with zipfile.ZipFile("DATA.zip","r") as zip_ref:
            zip_ref.extractall()
        # Delete DATA.zip
        print("Delete DATA.zip ...")
        os.remove("DATA.zip")

# ------------------------------------------------------------------------------------------------------------------
# This method creates a textfile which contains source and reference paths from the ACM-MM-Evaluation-Dataset
#
# Parameters
# dataset_path [String]: Path to the ACM-MM-Evaluation-Dataset
# outfile [String]: Path of the file where the source-reference pairs have to be saved
# ------------------------------------------------------------------------------------------------------------------
def createEvaluationFile(dataset_path, out_file, num_tests):
    files_256 = []
    files_512 = []
    files_1024 = []
    files_2048 = []
    files_4096 = []
    files_8192 = []
    for path, subdirs, files in os.walk(dataset_path):
        for name in files:
            if name.split("_")[0] == "256":
                files_256.append(path + "/" + name)
            elif name.split("_")[0] == "512":
                files_512.append(path + "/" + name)
            elif name.split("_")[0] == "1024":
                files_1024.append(path + "/" + name)
            elif name.split("_")[0] == "2048":
                files_2048.append(path + "/" + name)
            elif name.split("_")[0] == "4096":
                files_4096.append(path + "/" + name)
            elif name.split("_")[0] == "8192":
                files_8192.append(path + "/" + name)

    file1 = open(out_file,"w")
    eval_list = []

    for i in range(num_tests):
        print(num_tests)
        src_img = random.choice(files_512).replace(dataset_path, '')
        ref_img = random.choice(files_512).replace(dataset_path, '')
        if src_img + ref_img in eval_list:
            continue
        eval_list.append(src_img + ref_img)
        file1.writelines(src_img + " " + ref_img + "\n")


# ------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------
# Possible values for ct_approach:
# ["GLO",   support for [images, point clouds]
#  "PDF",   support for [images, point clouds]
#  "MKL",   support for [images, point clouds]
#  "NST",   support for [images]
#  "HIS",   support for [images]
#  "CAM",   support for [images]
#  "DPT",   support for [images]
#  "TPS",   support for [images]
#  "FUZ",   support for [images]
#  "GMM",   support for [images]
#  "E3D",   support for [point clouds]
#  "PSN",   support for [point clouds]
#  "FCM",   support for [images]
#  ]
# ------------------------------------------------------------------------------------------------------------------
# ------------------------------------------------------------------------------------------------------------------

if __name__ == '__main__':
    #src = Image(file_path='/Volumes/External/DATASETS/ACM-MM-Evaluation-Dataset/abstract/256_abstract-01.png')
    #ref = Image(file_path='/Volumes/External/DATASETS/ACM-MM-Evaluation-Dataset/abstract/256_abstract-02.png')   
    src = Image(file_path='/Volumes/External/DATASETS/ColorTransfer-Dataset/original/abstract/256_abstract-01.png')
    ref = Image(file_path='/Volumes/External/DATASETS/ColorTransfer-Dataset/original/abstract/256_abstract-02.png')  
    ct = ColorTransfer(src, ref, "HIS")
    out = ct.apply()["object"]
    out.write("/Volumes/External/DATASETS/ColorTransfer-Dataset/test_img.png")

    print("HEHE")
    exit()

    import matplotlib.pyplot as plt
    from mpl_toolkits import mplot3d
    from PIL import Image

    im = Image.open("/home/potechius/Projects/ColorTransferLab/server/data/Images/Lena.png")
    px = im.load()
    ax = plt.axes(projection = '3d')
    ax.axes.set_xlim3d(left=0., right=255)
    ax.axes.set_ylim3d(bottom=0., top=255) 
    ax.axes.set_zlim3d(bottom=0., top=255) 
    x = []
    y = []
    z = []
    c = []
    for row in range(0,im.height):
        print(row)
        for col in range(0, im.width):
            pix = px[col,row]
            newCol = (pix[0] / 255, pix[1] / 255, pix[2] / 255)

            if(not newCol in c):
                x.append(pix[0])
                y.append(pix[1])
                z.append(pix[2])
                c.append(newCol)
    ax.scatter(x,y,z, c = c)
    plt.show()
    exit()


    # try:

    # NOTE Temporary
    #src = Mesh2(file_path='/home/potechius/Projects/ColorTransferLab/server/data/PointClouds/athen_postprocessed.ply', datatype="PointCloud")
    #ref = Mesh2(file_path='/home/potechius/Projects/ColorTransferLab/server/data/PointClouds/Wappentier_blue.ply', datatype="PointCloud")
    #src = Mesh2(file_path='/home/potechius/Projects/ColorTransferLab/server/data/Meshes/$mesh$GameBoy_medium/GameBoy_medium.obj', datatype="Mesh")
    #src = Image(file_path='/home/potechius/Downloads/TestData-20230803T161847Z-001/TestData/256_abstract-08.png')
    src = Image(file_path='/home/potechius/Projects/ColorTransferLib/data/images/the_scream.jpg')
    #src = Mesh2(file_path='/home/potechius/Projects/ColorTransferLab/server/data/PointClouds/statue_athena_blue.ply', datatype="PointCloud")

    ref = Image(file_path='/home/potechius/Projects/ColorTransferLib/data/images/starry-night.jpg')
    #ref = Image(file_path='/home/potechius/Downloads/TestData-20230803T161847Z-001/TestData/stanford_bunny/stanford_bunny.png')
    #ref = Mesh2(file_path='/home/potechius/Downloads/TestData-20230803T161847Z-001/TestData/Orange.ply', datatype="PointCloud")
    #ref = Image(file_path='/home/potechius/Downloads/TestData-20230803T161847Z-001/TestData/palette.png')


    #print(src2.get_color_distribution().shape)
    ct = ColorTransfer(src, ref, "GLO")
    out = ct.apply()["object"]
    out.write("/home/potechius/Downloads/test_pc.png")
    exit()

    src = Mesh2('/home/potechius/Projects/ColorTransferLab/server/data/PointClouds/lamp.ply', "PointCloud")
    num_vertices = src.get_num_vertices()
    # new_cols = np.full((num_vertices, 3), 0.5)
    # src.set_colors(new_cols)
    print(src.get_colors().shape)
    # src.write("/home/potechius/Downloads/l.ply")

    exit()
    # NOTE Temporary
    # src = Image(file_path="/home/potechius/Downloads/TEST2/source.png")
    # ref = Image(file_path="/home/potechius/Downloads/TEST2/reference.png")
    # out = Image(file_path="/home/potechius/Downloads/TEST2/result_denoising_KNN.png")

    # cte = ColorTransferEvaluation(src, ref, out)
    # eva_out = cte.apply("IVEGSSIM")
    # print("SSIM: " + str(eva_out))
    # exit()

    #img_orig = cv2.imread("/media/potechius/Active_Disk/Datasets/ACM-MM-Evaluation-Dataset/interior/512_interior-02.png")
    #img_small = cv2.imread("/media/potechius/Active_Disk/Datasets/ACM-MM-Evaluation-Dataset/interior/512_interior-02_dithering-256.png")

    #out_path = "/home/potechius/Downloads/drive-download-20230511T071650Z-001/512_interior-02_dithering-16_gaussian.png"
    src_path = "/home/potechius/Downloads/TEST2/source.png"
    ref_path = "/home/potechius/Downloads/TEST2/reference.png"
    #src_path = "/media/potechius/Active_Disk/Datasets/ACM-MM-Evaluation-Dataset/closeup/512_closeup-01.png"
    #ref_path = "/media/potechius/Active_Disk/Datasets/ACM-MM-Evaluation-Dataset/nature/512_nature-06.png"
    # appr = ["GLO","FUZ","TPS","PDF","MKL","HIS","NST","CAM","DPT","RHG","BCC","FCM"]
    # for app in appr:
    #img = cv2.imread("/media/potechius/Active_Disk/Tests/MetricEvaluation/"+app+"/512_abstract-02__to__512_interior-07.png")
    output = img2img_test(src_path, ref_path, "FCM")
    status_code = output["status_code"]
    out_obj = output["object"]
    if status_code == -1:
        print("Color Transfer Failed")
    else:
        src = Image(file_path=src_path)
        ref = Image(file_path=ref_path)
        cte = ColorTransferEvaluation(src, ref, out_obj)
        eva_out = cte.apply("IVEGSSIM")
        print("IVEGSSIM: " + str(eva_out))
        #cv2.imwrite("/home/potechius/Downloads/TEST2/result_rotation_KNN.png", cv2.cvtColor(out_obj.get_raw(), cv2.COLOR_BGR2RGB)*255)
        cv2.imwrite("/home/potechius/Downloads/XCV.png", cv2.cvtColor(out_obj.get_raw(), cv2.COLOR_BGR2RGB)*255)

    exit()

    # Evaluation Test
    src_img = '/home/potechius/Downloads/source.png'
    ref_img = '/home/potechius/Downloads/reference.png'
    out_img = '/home/potechius/Downloads/result_GLO.png'

    evalm = ["BA","BRISQUE","CF","Corr","CSS","CTQM","FSIM","GSSIM","HI","IVEGSSIM","IVSSIM","LPIPS","MSE","MSSSIM",
             "NIMA", "NIQE", "PSNR", "RMSE", "SSIM", "VIS"]
    for eva in evalm:
        src = Image(file_path=src_img)
        ref = Image(file_path=ref_img)
        out = Image(file_path=out_img)
        cte = ColorTransferEvaluation(src, ref, out)
        eva_out = cte.apply(eva)
        print(eva + ": " + str(eva_out))
    exit()

    appr = ["GLO","FUZ","TPS","GMM","PDF","MKL","HIS","NST","CAM","DPT","E3D","PSN","RHG","BCC","FCM"]
    for ct_approach in appr:
        print(ct_approach)
        src_img = '/home/potechius/Downloads/source.png'
        ref_img = '/home/potechius/Downloads/reference.png'

        # Test
        output = img2img_test(src_img, ref_img, ct_approach)
        status_code = output["status_code"]
        out_obj = output["object"]
        if status_code == -1:
            print("Color Transfer Failed")
        else:
            cv2.imwrite("/home/potechius/Downloads/result_"+ct_approach+".png", cv2.cvtColor(out_obj.get_raw(), cv2.COLOR_BGR2RGB)*255)

    





